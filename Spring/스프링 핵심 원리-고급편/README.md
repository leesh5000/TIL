# 스프링 핵심 원리 - 고급편
인프런 김영한님의 [스프링 핵심 원리 - 고급편](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B3%A0%EA%B8%89%ED%8E%B8) 강의를 공부하고 정리하는 페이지입니다.

[강의 소스코드](https://github.com/leesh5000/Spring-Practice/tree/master/%EC%8A%A4%ED%94%84%EB%A7%81%20%ED%95%B5%EC%8B%AC%20%EC%9B%90%EB%A6%AC%20%EA%B3%A0%EA%B8%89%ED%8E%B8/advanced)는 유료 강의이기 때문에 Private 저장소에 저장합니다.

## 1. 예제 만들기

- 요구사항은 모두 만족했지만, TraceId를 매소드의 파라미터로 넘기는 것은 변경 사항에 유연하게 대응할 수 없다. -> 다른 대안이 필요


## 2. ThreadLocal

- traceIdHolder 필드를 사용하는 것은 동시성 문제를 발생시킬 수 있다. (fieldLogTrace가 싱글톤으로 등록되었기 때문에)
- `2022-05-03 23:41:22.071  INFO 96432 --- [nio-8080-exec-5] h.advanced.trace.logtrace.FieldLogTrace  : [62ad053b] |-->OrderServiceV1.orderItem()` 톰캣에서 제공하는 thread ID `[nio-8080-exec-5]`

### 2.4. 동시성 문제 - 예제 코드
- 공유 자원에 대한 동시 접근으로 생기는 문제에 대해 알아봅시다.
- 싱글톤 객체의 필드에 접근할 떄 주의
- 지역변수에서는 동시성 문제가 발생하지 않는다. 왜냐하면, 쓰레드 마다 지역변수에서는 각가 다른 메모리 영역이 할당되기 때문이다.
- 싱글톤 객체의 멤버변수, static과 같은 공용 필드와 같은 곳에서 동시성 문제가 발생한다.

따라서, 이와같이 싱글톤 객체의 필드를 사용하면서 동시성 문제를 해결하기 위해서 사용하는 것이 `ThreadLocal`이다.

### 2.5. ThreadLocal - 소개
- ThreadLocal은 각 쓰레드마다 별도의 내부 저장소를 가지는 저장소 - 동시성 문제 해결
- 주의! 해당 쓰레드가 쓰레드 로컬을 모두 사용하고 나면, `ThreadLocal.remove()`를 호출해서 쓰레드 로컬에 저장된 값을 제거해 주어야한다. 제거를 하지 않으면 메모리 누수 발생 가능성
- `ThreadLocal.remove()`는 모든 ThreadLocal을 제거하는 것은 아니고, 해당 쓰레드의 전용 보관소만 제거

### 2.6. ThreadLocal - 예제 코드

### 2.7. 쓰레드 로컬 동기화 - 개발

### 2.8. 쓰레드 로컬 동기화 - 적용

### 2.9. 쓰레드 로컬 - 주의사항
- 쓰레드 로컬의 값을 사용 후 제거하지 않으면, WAS처럼 쓰레드 풀을 사용하는 경우 심각한 문제가 발생할 수 있음
- WAS는 사용이 끝난 쓰레드를 제거하지는 않고, 쓰레드 풀에 보관하여 재사용한다. (쓰레드 생성 비용은 비싸기 때문에)
- 중요한 점은, 이 때 쓰레드 로컬에 있는 쓰레드A의 데이터도 함께 살아있다는 것이다. (쓰레드 A를 제거하지 않았기 때문에)
- 이 때, 사용자B의 요청이 왔을 때, WAS가 쓰레드A를 꺼내고, 이 쓰레드A가 쓰레드 로컬에서 정보를 조회하면 이 때 사용자A의 데이터가 사용자B에게 전달된다.

따라서, 이런 문제를 예방하려면 반드시 쓰레드 로컬의 값을 다 썼으면 제거를 해주어야한다.

## 3. 템플릿 메서드 패턴과 콜백 패턴

### 3.1. 템플릿 메서드 패턴 - 시작
- 로그 추적기를 도입하려고 하니, 비즈니스 로직의 핵심 기능보다 로그를 찍는 부가 기능이 더 많아지는 문제가 생긴다.
- **핵심 기능**은 해당 메서드의 핵심 비즈니스 로직이며, **부가 기능**은 핵심 기능을 보조하기 위해 제공되는 기능으로, 로그 추적, 트랜잭션 기능 등이 있다.

좋은 설계에 대해서
