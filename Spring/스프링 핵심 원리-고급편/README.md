# 스프링 핵심 원리 - 고급편
인프런 김영한님의 [스프링 핵심 원리 - 고급편](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B3%A0%EA%B8%89%ED%8E%B8) 강의를 공부하고 정리하는 페이지입니다.

[강의 소스코드](https://github.com/leesh5000/Spring-Practice/tree/master/%EC%8A%A4%ED%94%84%EB%A7%81%20%ED%95%B5%EC%8B%AC%20%EC%9B%90%EB%A6%AC%20%EA%B3%A0%EA%B8%89%ED%8E%B8/advanced)는 유료 강의이기 때문에 Private 저장소에 저장합니다.

## 1. 예제 만들기

- 요구사항은 모두 만족했지만, TraceId를 매소드의 파라미터로 넘기는 것은 변경 사항에 유연하게 대응할 수 없다. -> 다른 대안이 필요


## 2. ThreadLocal

- traceIdHolder 필드를 사용하는 것은 동시성 문제를 발생시킬 수 있다. (fieldLogTrace가 싱글톤으로 등록되었기 때문에)
- `2022-05-03 23:41:22.071  INFO 96432 --- [nio-8080-exec-5] h.advanced.trace.logtrace.FieldLogTrace  : [62ad053b] |-->OrderServiceV1.orderItem()` 톰캣에서 제공하는 thread ID `[nio-8080-exec-5]`

### 2.4. 동시성 문제 - 예제 코드
- 공유 자원에 대한 동시 접근으로 생기는 문제에 대해 알아봅시다.
- 싱글톤 객체의 필드에 접근할 떄 주의
- 지역변수에서는 동시성 문제가 발생하지 않는다. 왜냐하면, 쓰레드 마다 지역변수에서는 각가 다른 메모리 영역이 할당되기 때문이다.
- 싱글톤 객체의 멤버변수, static과 같은 공용 필드와 같은 곳에서 동시성 문제가 발생한다.

따라서, 이와같이 싱글톤 객체의 필드를 사용하면서 동시성 문제를 해결하기 위해서 사용하는 것이 `ThreadLocal`이다.

### 2.5. ThreadLocal - 소개
- ThreadLocal은 각 쓰레드마다 별도의 내부 저장소를 가지는 저장소 - 동시성 문제 해결
- 주의! 해당 쓰레드가 쓰레드 로컬을 모두 사용하고 나면, `ThreadLocal.remove()`를 호출해서 쓰레드 로컬에 저장된 값을 제거해 주어야한다. 제거를 하지 않으면 메모리 누수 발생 가능성
- `ThreadLocal.remove()`는 모든 ThreadLocal을 제거하는 것은 아니고, 해당 쓰레드의 전용 보관소만 제거

### 2.6. ThreadLocal - 예제 코드

### 2.7. 쓰레드 로컬 동기화 - 개발

### 2.8. 쓰레드 로컬 동기화 - 적용

### 2.9. 쓰레드 로컬 - 주의사항
- 쓰레드 로컬의 값을 사용 후 제거하지 않으면, WAS처럼 쓰레드 풀을 사용하는 경우 심각한 문제가 발생할 수 있음
- WAS는 사용이 끝난 쓰레드를 제거하지는 않고, 쓰레드 풀에 보관하여 재사용한다. (쓰레드 생성 비용은 비싸기 때문에)
- 중요한 점은, 이 때 쓰레드 로컬에 있는 쓰레드A의 데이터도 함께 살아있다는 것이다. (쓰레드 A를 제거하지 않았기 때문에)
- 이 때, 사용자B의 요청이 왔을 때, WAS가 쓰레드A를 꺼내고, 이 쓰레드A가 쓰레드 로컬에서 정보를 조회하면 이 때 사용자A의 데이터가 사용자B에게 전달된다.

따라서, 이런 문제를 예방하려면 반드시 쓰레드 로컬의 값을 다 썼으면 제거를 해주어야한다.

## 3. 템플릿 메서드 패턴과 콜백 패턴

### 3.1. 템플릿 메서드 패턴 - 시작
- 로그 추적기를 도입하려고 하니, 비즈니스 로직의 핵심 기능보다 로그를 찍는 부가 기능이 더 많아지는 문제가 생긴다.
- **핵심 기능**은 해당 메서드의 핵심 비즈니스 로직이며, **부가 기능**은 핵심 기능을 보조하기 위해 제공되는 기능으로, 로그 추적, 트랜잭션 기능 등이 있다.

#### 좋은 설계에 대해서
- 좋은 설계란, 변하는 것(핵심 로직)과 변하지 않는 것(부가 기능)을 잘 분리하는 것이다.
- 템플릿 메서드 패턴은 이런 문제를 해결하는 디자인 패턴이다.

### 3.2. 템플릿 메서드 패턴 - 예제1
- 변하는 부분과 변하지 않는 부분이 섞인 테스트 코드
- 템플릿 메서드 패턴을 사용하면, 변하는 부분과 변하지 않는 부분을 분리해서 모듈화 가능

### 3.3. 템플릿 메서드 패턴 - 예제2
- 템플릿 메서드 패턴은 부모 클래스에 변하지 않는 템플릿 코드를 만들고, 자식 클래스에서 변하는 부분을 상속과 오버라이딩을 사용해서 구현한다.
- 템플릿 메서드 패턴을 활용하면 코드 중복을 제거할 수 있다.
- 템플릿 메서드 패턴은 OCP 원칙을 보장한다.

### 3.4. 템플릿 메서드 패턴 - 예제3
- 템플릿 메서드 패턴은 자식 클래스를 계속 만들어줘야한다는 단점이 있다. -> 익명 내부 클래스를 사용하면 해결 가능 (클래스 파일을 만들지 않아도 됨)

### 3.5. 템플릿 메서드 패턴 - 적용1
-  제너릭 : 타입에 대한 정보를 객체 생성 시점으로 미룬다.
-  익명 내부 클래스를 활용하면, 별도의 자식 클래스 파일을 만들지 않아도 된다.
-  제네릭에서 반환 타입이 없을 때는 Void 사용

### 3.6. 템플릿 메서드 패턴 - 적용2
- 비교
  - OrderServiceV0 : 핵심 기능만 있다.
  - OrderServiceV3 : 핵심 기능과 부가 기능이 함께 섞여있음
  - OrderServiceV4 : 핵심 기능과 템플릿을 호출하는 코드가 섞여있음
- 좋은 설계란, 변경이 일어날 때 자연스럽게 드러난다.
- 예를들어, 로그 남기는 로직을 변경한다고 하면, AbstractTemplate만 변경하면 된다.

#### 단일 책임 원칙
- V4는 단일책임 원칙을 지킨다.
- 변경에 유연하게 대처할 수 있음

### 3.7. 템플릿 메서드 패턴 - 정의
- "작업에서 알고리즘의 골격을 정의하고 일부 단계를 하위 클래스로 연기합니다. 템플릿 메서드를 사용하면 하위 클래스가 알고리즘의 구조를 변경하지 않고도 알고리즘의 특정 단게를 재정의 할 수 있습니다." - GOF
- 부모클래스에 알고리즘의 골격 정의, 변경되는 로직은 하위 클래스에서 정의. 즉, 상속과 오버라이딩을 통한 다형성으로 문제를 해결하는 것
- 하지만, 템플릿 메서드 패턴은 자식 클래스와 부모 클래스가 강하게 결합되는 문제가 있다.
  - 자식 클래스는 부모 클래스의 기능을 전혀 사용하지 않지만, 템플릿 메서드 패턴을 위해서 부모 클래스를 상속받고 있다. 이것은 좋은 설계가 아니다.
  - 이러한 문제를 해결하기 위해서는 템플릿 메서드 패턴과 비슷한 역할을 하면서 상속의 단점을 제거할 수 있는 디자인 패턴이 바로 `전략 패턴(Strategy Pattern)`이다. :: **"상속보다 위임"** 

### 3.8. 전략 패턴 - 시작
- 템플릿 메서드 패턴보다 더 자주사용되고 더 좋은 전략 패턴

### 3.9. 전략 패턴 - 예제1

<img height="50%" src="전략패턴.png" width="50%"/>

- 템플릿 메서드 패턴은 부모 클래스에서 변하지 않는 템플릿, 자식 클래스에서 변하는 부분을 두어 상속을 사용해서 문제 해결 -> 자식 클래스가 굳이 부모 클래스의 기능을 사용하지 않는데도, 의존 관계가 맺어지는 문제 발생
- 전략 패턴은 변하지 않는 부분을 `Context`에 두고, 변하는 부분을 `Strategy`라는 인터페이스를 만들고 해당 인터페이스를 구현하도록 하여 문제 해결 -> 상속이 아니라 위임으로 문제 해결
- 전략 패턴의 의도 : 알고리즘 제품 군을 정의하고, 각각을 캡슐화 하여 상호 교환 가능하게 만들자.
- 전략 패턴의 핵심은 `Context`는 Strategy 인터페이스에만 의존한다는 것이다. 따라서, Strategy의 구현체를 변경하거나 새로 만들어도 Context 에는 영향을 주지 않는다. -> 다른 전략을 쓰고자 구현체를 변경한다해도 `Context`는 변경할 필요가 없다.
- 스프링의 의존관계 주입 시 사용하는 것이 바로 이 전략패턴이다.

#### 전략 패턴 실행 그림

<img height="50%" src="전략패턴실행그림.png" width="50%"/>

1. Context에 원하는 Strategy 구현체를 주입한다.
2. 클라이언트는 Context를 실행한다.
3. Context 로직 중간에 strategy.call()을 호출하여 주입받은 strategy 로직을 실행한다.
4. context는 나머지 로직을 실행한다.

#### 템플릿 메서드 패턴과의 비교 - "상속보다는 위임"

- 템플릿 메서드 패턴은 부모 클래스가 변경되는 경우 자식 클래스도 모두 영향이 간다.
- 전략 패턴은 인터페이스를 구현하였기 때문에, 영향을 받지 않고 단단하게 흘러갈 수 있다.